<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Private Video Call - Secure & Private</title>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f0f0f">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --primary-glow: rgba(59,130,246,0.35);
            --danger: #ef4444;
            --danger-glow: rgba(239,68,68,0.35);
            --success: #22c55e;
            --warning: #f59e0b;
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-2: #242424;
            --surface-3: #2e2e2e;
            --border: rgba(255,255,255,0.08);
            --border-hover: rgba(255,255,255,0.15);
            --text: #f4f4f5;
            --text-2: #a1a1aa;
            --text-3: #71717a;
            --chat-bg: rgba(15,15,15,0.98);
            --radius: 16px;
            --radius-sm: 10px;
            --radius-pill: 999px;
        }

        body {
            font-family: 'DM Sans', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            height: -webkit-fill-available;
            overflow: hidden;
            position: fixed;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
        }

        /* ─── Lucide Icon helper ─── */
        .icon { display: inline-flex; align-items: center; justify-content: center; }
        .icon svg { stroke: currentColor; fill: none; }

        /* ─── HTTPS Warning ─── */
        .https-warning {
            position: fixed; top: 0; left: 0; right: 0;
            background: var(--danger); color: white;
            text-align: center; padding: 12px; z-index: 2000;
            font-weight: 500; display: none; font-size: 14px;
        }
        .https-warning.show { display: block; }

        /* reconnection banner removed - auto-reconnect is silent */

        /* ─── Pages ─── */
        .page {
            display: none !important;
            height: 100% !important; width: 100% !important;
            position: absolute !important; top: 0 !important;
            left: 0 !important; right: 0 !important; bottom: 0 !important;
            overflow-y: auto !important; -webkit-overflow-scrolling: touch !important;
            background: var(--bg) !important;
        }
        .page.active { display: block !important; z-index: 10 !important; }

        /* ─── Landing Page ─── */
        #landing-page {
            display: flex !important; flex-direction: column !important;
            align-items: center !important; justify-content: center !important;
            padding: 24px !important;
            background: radial-gradient(ellipse 80% 60% at 50% 0%, rgba(59,130,246,0.12) 0%, transparent 70%), var(--bg) !important;
        }
        #landing-page:not(.active) { display: none !important; }

        .logo {
            text-align: center; margin-bottom: 48px;
            animation: fadeInDown 0.6s cubic-bezier(.22,.68,0,1.2) both;
        }

        .logo-icon {
            width: 80px; height: 80px;
            background: linear-gradient(135deg, var(--primary), #818cf8);
            border-radius: 28px; display: flex;
            align-items: center; justify-content: center;
            margin: 0 auto 24px;
            box-shadow: 0 0 40px var(--primary-glow), 0 8px 32px rgba(0,0,0,0.5);
            color: white;
        }

        .logo h1 {
            font-size: 30px; font-weight: 700; letter-spacing: -0.5px;
            background: linear-gradient(135deg, #fff 30%, var(--primary) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        .logo .subtitle { color: var(--text-3); font-size: 15px; margin-top: 6px; }

        .action-buttons {
            width: 100%; max-width: 400px;
            animation: fadeInUp 0.6s cubic-bezier(.22,.68,0,1.2) 0.15s both;
        }

        .primary-btn, .secondary-btn {
            width: 100%; padding: 16px 20px; border: none;
            border-radius: var(--radius); font-size: 15px; font-weight: 600;
            cursor: pointer; display: flex; align-items: center;
            justify-content: center; gap: 10px;
            transition: all 0.2s cubic-bezier(.22,.68,0,1.2);
            font-family: 'DM Sans', sans-serif;
        }
        .primary-btn {
            background: var(--primary); color: white;
            box-shadow: 0 6px 24px var(--primary-glow);
        }
        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px var(--primary-glow);
            background: #4f8ef7;
        }
        .secondary-btn {
            background: var(--surface-2); color: var(--text);
            border: 1px solid var(--border);
        }
        .secondary-btn:hover { background: var(--surface-3); border-color: var(--border-hover); }
        .primary-btn:active, .secondary-btn:active { transform: scale(0.97); }

        .or-divider {
            text-align: center; margin: 20px 0;
            color: var(--text-3); font-size: 13px; position: relative;
        }
        .or-divider::before, .or-divider::after {
            content: ''; position: absolute; top: 50%;
            width: calc(50% - 30px); height: 1px; background: var(--border);
        }
        .or-divider::before { left: 0; }
        .or-divider::after { right: 0; }

        .join-section { display: flex; flex-direction: column; gap: 10px; }

        #room-code-input {
            width: 100%; padding: 16px 20px; border: 1px solid var(--border);
            border-radius: var(--radius); background: var(--surface-2);
            color: var(--text); font-size: 20px; text-align: center;
            letter-spacing: 4px; font-weight: 700; font-family: 'Space Mono', monospace;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        #room-code-input:focus {
            outline: none; border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-glow);
        }
        #room-code-input::placeholder {
            color: var(--text-3); font-weight: 400;
            letter-spacing: 1px; font-size: 15px; font-family: 'DM Sans', sans-serif;
        }

        .info-text { margin-top: 28px; text-align: center; color: var(--text-3); font-size: 13px; }
        .info-text span { color: var(--text-2); }

        /* ─── Call Page ─── */
        #call-page {
            display: flex !important; flex-direction: column !important;
            height: 100% !important; overflow: hidden !important;
            background: #000 !important;
        }
        #call-page:not(.active) { display: none !important; }

        /* ─── Call Header ─── */
        .call-header {
            background: rgba(15,15,15,0.9);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 12px 16px;
            padding-left: max(16px, env(safe-area-inset-left));
            padding-right: max(16px, env(safe-area-inset-right));
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border); flex-shrink: 0;
            z-index: 50;
        }

        .room-info {
            display: flex; align-items: center; gap: 8px;
            background: var(--surface-2); padding: 6px 14px;
            border-radius: var(--radius-pill); border: 1px solid var(--border);
        }
        .room-label { color: var(--text-3); font-size: 12px; font-weight: 500; }
        .room-code {
            color: var(--primary); font-weight: 700; font-size: 17px;
            letter-spacing: 2px; font-family: 'Space Mono', monospace;
        }

        .copy-options { display: flex; gap: 4px; margin-left: 2px; }

        .icon-btn {
            background: var(--surface-3); border: 1px solid var(--border);
            cursor: pointer; padding: 7px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; color: var(--text-2); position: relative;
        }
        .icon-btn:hover { background: var(--surface-3); border-color: var(--border-hover); color: var(--text); transform: scale(1.05); }
        .icon-btn:active { transform: scale(0.95); }

        .header-right { display: flex; align-items: center; gap: 8px; }

        .participant-pill {
            display: flex; align-items: center; gap: 6px;
            background: var(--surface-2); padding: 6px 14px;
            border-radius: var(--radius-pill); border: 1px solid var(--border);
            color: var(--text-2); font-size: 13px; font-weight: 500;
        }
        .participant-pill .count {
            color: var(--primary); font-weight: 700; font-size: 15px;
            font-family: 'Space Mono', monospace;
        }

        /* Chat toggle with badge */
        .chat-toggle-btn {
            position: relative;
            background: var(--surface-2); border: 1px solid var(--border);
            cursor: pointer; padding: 8px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; color: var(--text-2);
        }
        .chat-toggle-btn:hover { border-color: var(--border-hover); color: var(--text); }
        .chat-toggle-btn:active { transform: scale(0.95); }
        .chat-toggle-btn.has-unread { color: var(--primary); border-color: var(--primary); }

        .chat-badge {
            position: absolute; top: -6px; right: -6px;
            background: var(--danger); color: white;
            font-size: 10px; font-weight: 700; line-height: 1;
            min-width: 18px; height: 18px; border-radius: var(--radius-pill);
            display: none; align-items: center; justify-content: center;
            padding: 0 4px; border: 2px solid #000;
            animation: badgePop 0.3s cubic-bezier(.22,.68,0,1.5);
        }
        .chat-badge.show { display: flex; }

        @keyframes badgePop {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }
        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.7); }
            50% { box-shadow: 0 0 0 6px rgba(239,68,68,0); }
        }
        .chat-badge.pulse { animation: badgePulse 1s ease infinite; }

        /* ─── Google Meet–style Video Grid ─── */
        #video-grid {
            flex: 1; display: flex; flex-direction: column;
            background: #111; min-height: 0; overflow: hidden;
            padding: 0;
        }

        /* ── Spotlight area (main big tile) ── */
        #spotlight-area {
            flex: 1; position: relative; min-height: 0;
            display: flex; align-items: center; justify-content: center;
            background: #111; overflow: hidden;
        }
        #spotlight-area .video-container {
            width: 100%; height: 100%;
            border-radius: 0; border: none;
            box-shadow: none; aspect-ratio: unset;
        }

        /* ── Thumbnail strip ── */
        #thumbnail-strip {
            flex-shrink: 0; display: flex; flex-direction: row;
            gap: 6px; padding: 6px;
            padding-left: max(6px, env(safe-area-inset-left));
            padding-right: max(6px, env(safe-area-inset-right));
            background: #000; overflow-x: auto; overflow-y: hidden;
            -webkit-overflow-scrolling: touch; min-height: 0;
            scrollbar-width: thin; scrollbar-color: #333 transparent;
            height: 120px;
        }
        #thumbnail-strip::-webkit-scrollbar { height: 3px; }
        #thumbnail-strip::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        #thumbnail-strip.hidden { display: none; }

        #thumbnail-strip .video-container {
            flex-shrink: 0; aspect-ratio: 16/9; height: 100%;
            width: auto; border-radius: 10px; cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            transition: border-color 0.2s, transform 0.15s;
        }
        #thumbnail-strip .video-container:hover {
            border-color: var(--primary); transform: scale(1.03);
        }
        #thumbnail-strip .video-container.thumbnail-active {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary-glow);
        }

        /* Solo mode — only 1 person: fill full grid, no strip */
        #video-grid.solo #spotlight-area { flex: 1; }
        #video-grid.solo #thumbnail-strip { display: none; }

        /* ── Empty state ── */
        .video-grid-empty-msg {
            display: none; width: 100%; height: 100%;
            align-items: center; justify-content: center;
            flex-direction: column; gap: 12px;
            color: var(--text-3); font-size: 15px; text-align: center;
            padding: 20px; position: absolute; top: 0; left: 0;
        }
        .video-grid-empty-msg.show { display: flex; }
        .video-grid-empty-msg .empty-icon { color: var(--text-3); opacity: 0.4; margin-bottom: 4px; }
        .video-grid-empty-msg p { color: var(--text-3); font-size: 14px; line-height: 1.6; }

        /* ── Video container base ── */
        .video-container {
            position: relative; background: var(--surface);
            border-radius: 14px; overflow: hidden;
            border: 1.5px solid rgba(255,255,255,0.06);
            box-shadow: 0 4px 24px rgba(0,0,0,0.6);
            transition: border-color 0.25s, transform 0.15s;
        }
        .video-container video {
            width: 100%; height: 100%; object-fit: cover; background: #000; pointer-events: none;
            display: block;
        }
        .video-container.video-off video { opacity: 0; }
        .video-container .avatar {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background: var(--surface-2); z-index: 5; color: var(--text-3);
        }
        .video-container.video-off .avatar { display: flex; }
        .video-container:not(.video-off) .avatar { display: none; }

        /* ── Mirror: front camera mirrors, back camera does NOT ── */
        .video-container.cam-front video  { transform: scaleX(-1); }
        .video-container.cam-back  video  { transform: scaleX(1);  }
        /* Remote users never mirrored */
        .video-container:not(.local-video) video { transform: scaleX(1); }

        .local-video { border-color: rgba(59,130,246,0.5); }
        .local-video:hover { border-color: rgba(59,130,246,0.8); }

        /* Participant name tag */
        .participant-name {
            position: absolute; bottom: 8px; left: 8px;
            background: rgba(0,0,0,0.75); padding: 5px 12px;
            border-radius: var(--radius-pill); font-size: 12px; font-weight: 500;
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.08); z-index: 10; color: var(--text);
        }

        /* Audio indicator */
        .audio-indicator {
            position: absolute; top: 8px; right: 8px;
            width: 32px; height: 32px; background: rgba(0,0,0,0.75);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.08); z-index: 10;
            color: var(--text); transition: background 0.2s, color 0.2s;
        }
        .audio-indicator.muted { background: var(--danger); color: white; }

        /* Connection quality */
        .connection-quality {
            position: absolute; top: 8px; left: 8px;
            display: flex; align-items: flex-end; gap: 2px;
            background: rgba(0,0,0,0.75); padding: 6px 10px;
            border-radius: var(--radius-pill); backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.08); z-index: 10;
        }
        .quality-bar {
            width: 3px; border-radius: 2px; background: #333; transition: background 0.3s;
        }
        .quality-bar:nth-child(1) { height: 6px; }
        .quality-bar:nth-child(2) { height: 10px; }
        .quality-bar:nth-child(3) { height: 14px; }
        .quality-bar:nth-child(4) { height: 18px; }
        .quality-bar.active { background: var(--success); }
        .quality-bar.active.fair { background: var(--warning); }
        .quality-bar.active.poor { background: var(--danger); }

        /* PiP btn */
        .pip-btn {
            position: absolute; bottom: 8px; right: 8px;
            background: rgba(0,0,0,0.75); border: 1px solid rgba(255,255,255,0.08);
            cursor: pointer; padding: 7px; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(8px); z-index: 10; transition: all 0.2s; color: var(--text-2);
        }
        .pip-btn:hover { background: rgba(0,0,0,0.9); color: var(--text); }
        .pip-btn:active { transform: scale(0.95); }

        /* Spotlight name overlay */
        #spotlight-area .participant-name {
            font-size: 14px; padding: 6px 16px;
            bottom: 16px; left: 16px;
        }
        #spotlight-area .audio-indicator {
            width: 38px; height: 38px; top: 14px; right: 14px;
        }
        #spotlight-area .connection-quality {
            top: 14px; left: 14px; padding: 7px 12px;
        }
        #spotlight-area .quality-bar:nth-child(1) { height: 8px; }
        #spotlight-area .quality-bar:nth-child(2) { height: 13px; }
        #spotlight-area .quality-bar:nth-child(3) { height: 18px; }
        #spotlight-area .quality-bar:nth-child(4) { height: 24px; }

        /* "Click to spotlight" hint on thumbnails */
        #thumbnail-strip .video-container::after {
            content: 'Pin'; position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); color: white;
            font-size: 11px; font-weight: 600; padding: 4px 10px;
            border-radius: 20px; opacity: 0;
            transition: opacity 0.2s; pointer-events: none;
        }
        #thumbnail-strip .video-container:hover::after { opacity: 1; }

        @media (max-width: 600px) {
            #thumbnail-strip { height: 90px; }
        }

        /* ─── Browser extension iframe reposition ─── */
        /* Repositions the nr-ext-rsicon extension button above the call controls */
        #nr-ext-rsicon {
            bottom: 90px !important;
            top: auto !important;
            right: 16px !important;
            left: auto !important;
            position: fixed !important;
            z-index: 9999 !important;
        }

        .call-controls {
            background: rgba(15,15,15,0.95);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 14px 12px;
            padding-left: max(12px, env(safe-area-inset-left));
            padding-right: max(12px, env(safe-area-inset-right));
            padding-bottom: max(14px, env(safe-area-inset-bottom, 14px));
            display: flex; justify-content: center; align-items: center;
            gap: 10px; border-top: 1px solid var(--border); flex-shrink: 0;
        }

        .control-btn {
            background: var(--surface-2); border: 1.5px solid var(--border);
            color: var(--text-2); cursor: pointer;
            display: flex; flex-direction: column; align-items: center;
            gap: 5px; padding: 12px 8px; border-radius: 14px;
            min-width: 68px; flex: 1; max-width: 82px;
            transition: all 0.2s cubic-bezier(.22,.68,0,1.2);
            font-family: 'DM Sans', sans-serif;
        }
        .control-btn:hover { background: var(--surface-3); border-color: var(--border-hover); color: var(--text); transform: translateY(-1px); }
        .control-btn:active { transform: scale(0.95); }
        .control-btn span { font-size: 10px; font-weight: 500; color: inherit; }
        .control-btn.active {
            background: var(--primary); border-color: transparent; color: white;
            box-shadow: 0 4px 16px var(--primary-glow);
        }
        .control-btn.danger { border-color: rgba(239,68,68,0.25); }
        .control-btn.danger:hover { background: rgba(239,68,68,0.15); color: var(--danger); border-color: rgba(239,68,68,0.5); }
        .control-btn.danger.active {
            background: var(--danger); border-color: transparent; color: white;
            box-shadow: 0 4px 16px var(--danger-glow);
        }

        /* Camera flip button - only on mobile */
        #camera-flip { display: none; }
        @media (max-width: 768px) {
            #camera-flip { display: flex; }
        }

        /* ─── Chat Panel ─── */
        .chat-panel {
            position: absolute; right: 0; top: 0; bottom: 0;
            width: 100%; max-width: 360px;
            background: var(--chat-bg); backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex; flex-direction: column; z-index: 100;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(.22,.68,0,1.2);
            border-left: 1px solid var(--border); box-shadow: -8px 0 40px rgba(0,0,0,0.6);
        }
        .chat-panel.open { transform: translateX(0); }

        .chat-header {
            padding: 18px 20px; display: flex; justify-content: space-between;
            align-items: center; border-bottom: 1px solid var(--border); flex-shrink: 0;
        }
        .chat-header h3 { font-size: 17px; font-weight: 600; color: var(--text); }

        .chat-close {
            background: var(--surface-2); border: 1px solid var(--border);
            cursor: pointer; padding: 8px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; color: var(--text-2);
        }
        .chat-close:hover { color: var(--text); background: var(--surface-3); }

        .chat-messages {
            flex: 1; overflow-y: auto; padding: 16px;
            display: flex; flex-direction: column; gap: 10px;
            scrollbar-width: thin; scrollbar-color: var(--surface-3) transparent;
        }
        .chat-messages::-webkit-scrollbar { width: 4px; }
        .chat-messages::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }

        /* ── Message wrapper (holds bubble + action menu) ── */
        .chat-message-wrap {
            display: flex; flex-direction: column;
            align-self: flex-start; max-width: 82%;
            position: relative;
        }
        .chat-message-wrap.own { align-self: flex-end; }

        .chat-message {
            padding: 10px 14px; border-radius: 14px;
            background: var(--surface-2); word-wrap: break-word;
            border: 1px solid var(--border); animation: msgIn 0.2s ease;
            cursor: pointer; user-select: none;
            transition: filter 0.15s;
        }
        .chat-message:hover { filter: brightness(1.15); }
        .chat-message.own-message {
            background: var(--primary); border-color: transparent;
        }

        /* Reply preview bar inside bubble */
        .reply-preview {
            background: rgba(0,0,0,0.2); border-left: 3px solid rgba(255,255,255,0.4);
            border-radius: 6px; padding: 5px 8px; margin-bottom: 6px; font-size: 12px;
            color: rgba(255,255,255,0.75); line-height: 1.3;
        }
        .reply-preview .reply-author { font-weight: 700; font-size: 11px; margin-bottom: 2px; color: rgba(255,255,255,0.9); }
        .reply-preview .reply-text { opacity: 0.8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        .chat-message:not(.own-message) .reply-preview {
            background: rgba(255,255,255,0.08); border-left-color: var(--primary);
            color: var(--text-2);
        }
        .chat-message:not(.own-message) .reply-preview .reply-author { color: var(--primary); }
        .chat-message:not(.own-message) .reply-preview .reply-text { color: var(--text-3); }

        /* ── Floating action menu (copy / reply) ── */
        .msg-actions {
            display: none; position: absolute;
            background: var(--surface-3); border: 1px solid var(--border-hover);
            border-radius: 10px; overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            z-index: 200; white-space: nowrap;
            animation: actionsIn 0.15s cubic-bezier(.22,.68,0,1.2);
            flex-direction: row;
        }
        .msg-actions.show { display: flex; }
        /* Own messages: menu appears above-left */
        .chat-message-wrap.own .msg-actions { right: 0; bottom: calc(100% + 6px); }
        /* Others: menu appears above-right */
        .chat-message-wrap:not(.own) .msg-actions { left: 0; bottom: calc(100% + 6px); }

        @keyframes actionsIn {
            from { opacity: 0; transform: scale(0.85) translateY(6px); }
            to   { opacity: 1; transform: scale(1) translateY(0); }
        }

        .msg-action-btn {
            display: flex; align-items: center; gap: 7px;
            padding: 9px 14px; font-size: 13px; font-weight: 500;
            color: var(--text-2); background: none; border: none;
            cursor: pointer; font-family: 'DM Sans', sans-serif;
            transition: background 0.15s, color 0.15s;
        }
        .msg-action-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }
        .msg-action-btn + .msg-action-btn { border-left: 1px solid var(--border); }
        .msg-action-btn.reply-btn:hover { color: var(--primary); }
        .msg-action-btn.copy-btn:hover { color: var(--success); }

        /* ── Reply compose bar (above chat input) ── */
        .reply-bar {
            display: none; align-items: center; gap: 8px;
            padding: 8px 16px; background: var(--surface-2);
            border-top: 1px solid var(--border);
            animation: replyBarIn 0.2s ease;
        }
        .reply-bar.show { display: flex; }
        @keyframes replyBarIn {
            from { opacity: 0; transform: translateY(6px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        .reply-bar-content {
            flex: 1; border-left: 3px solid var(--primary);
            padding: 4px 10px; border-radius: 0 6px 6px 0;
            background: rgba(59,130,246,0.1);
            min-width: 0;
        }
        .reply-bar-author { font-size: 11px; font-weight: 700; color: var(--primary); margin-bottom: 1px; }
        .reply-bar-text { font-size: 12px; color: var(--text-3); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .reply-bar-close {
            background: none; border: none; color: var(--text-3);
            cursor: pointer; padding: 4px; border-radius: 6px; flex-shrink: 0;
            display: flex; transition: color 0.15s;
        }
        .reply-bar-close:hover { color: var(--text); }
        @keyframes msgIn {
            from { opacity: 0; transform: translateY(8px) scale(0.97); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .message-sender { font-size: 11px; font-weight: 600; margin-bottom: 3px; color: var(--text-3); }
        .own-message .message-sender { color: rgba(255,255,255,0.7); }
        .message-text { font-size: 14px; line-height: 1.45; color: var(--text); }
        .own-message .message-text { color: white; }
        .message-time { font-size: 10px; margin-top: 4px; opacity: 0.55; text-align: right; }

        .chat-input-area {
            padding: 16px; border-top: 1px solid var(--border);
            display: flex; gap: 10px; align-items: center;
        }
        #chat-input {
            flex: 1; background: var(--surface-2); border: 1.5px solid var(--border);
            border-radius: var(--radius-pill); padding: 11px 16px;
            color: var(--text); font-size: 14px; font-family: 'DM Sans', sans-serif;
            transition: border-color 0.2s;
        }
        #chat-input:focus { outline: none; border-color: var(--primary); }
        #chat-input::placeholder { color: var(--text-3); }
        #send-chat {
            background: var(--primary); border: none; border-radius: 50%;
            width: 42px; height: 42px; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; color: white;
            box-shadow: 0 4px 12px var(--primary-glow);
        }
        #send-chat:hover { background: var(--primary-dark); transform: scale(1.05); }
        #send-chat:active { transform: scale(0.95); }

        /* ─── Loading Overlay ─── */
        .loading-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.92); display: none; flex-direction: column;
            align-items: center; justify-content: center; z-index: 1000;
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
        }
        .spinner {
            width: 44px; height: 44px; border: 3px solid var(--surface-2);
            border-top-color: var(--primary); border-radius: 50%;
            animation: spin 0.8s linear infinite; margin-bottom: 16px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading-message { color: var(--text-2); font-size: 15px; font-weight: 500; }

        /* ─── Toast ─── */
        .toast {
            position: fixed; bottom: 28px; left: 50%;
            transform: translateX(-50%);
            background: rgba(30,30,30,0.95); color: var(--text);
            padding: 12px 22px; border-radius: var(--radius-pill);
            font-size: 14px; font-weight: 500; z-index: 1001;
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            animation: toastIn 0.3s cubic-bezier(.22,.68,0,1.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            border: 1px solid var(--border); max-width: 90%; text-align: center;
            display: flex; align-items: center; gap: 8px;
        }
        .toast.toast-important { border-color: var(--warning); color: var(--warning); }
        @keyframes toastIn {
            from { opacity: 0; transform: translate(-50%, 16px) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, 0) scale(1); }
        }
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-24px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(24px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ─── Responsive ─── */
        @media (max-width: 768px) and (orientation: landscape) {
            .video-container { width: calc(33.333% - 4px); }
            .control-btn { min-width: 58px; }
        }
        @media (max-width: 480px) {
            .video-container { width: 100%; }
            .control-btn { min-width: 58px; }
            .chat-panel { max-width: 100%; }
        }
        @supports (padding: max(0px)) {
            .call-header { padding-top: max(12px, env(safe-area-inset-top)); }
            .call-controls { padding-bottom: max(14px, env(safe-area-inset-bottom, 14px)); }
        }
    </style>
</head>
<body>
    <div id="https-warning" class="https-warning">
        ⚠️ HTTPS is required for video calls. Please access this page via HTTPS.
    </div>

    <!-- reconnection is now silent/automatic - no banner -->

    <div class="container" style="height:100vh;height:-webkit-fill-available;display:flex;flex-direction:column;width:100%;position:relative;">

        <!-- ─── Landing Page ─── -->
        <div id="landing-page" class="page active">
            <div class="logo">
                <div class="logo-icon">
                    <i data-lucide="video" style="width:36px;height:36px;stroke:white;fill:none;"></i>
                </div>
                <h1>Private Video Call</h1>
                <p class="subtitle">Secure · Private · No Login Required</p>
            </div>

            <div class="action-buttons">
                <button id="create-room" class="primary-btn">
                    <i data-lucide="plus-circle" style="width:20px;height:20px;flex-shrink:0;"></i>
                    Create New Room
                </button>

                <div class="or-divider">OR</div>

                <div class="join-section">
                    <input
                        type="text" id="room-code-input"
                        placeholder="Enter 4-digit code"
                        maxlength="4" autocomplete="off"
                        inputmode="numeric" pattern="[0-9]*"
                    >
                    <button id="join-room" class="secondary-btn">
                        <i data-lucide="log-in" style="width:18px;height:18px;flex-shrink:0;"></i>
                        Join Room
                    </button>
                </div>

                <div class="info-text">
                    <span>Share the code</span> · <span>Instant connection</span> · <span>Auto cleanup</span>
                </div>
            </div>
        </div>

        <!-- ─── Call Page ─── -->
        <div id="call-page" class="page">
            <div class="call-header">
                <div class="room-info">
                    <span class="room-label">Room</span>
                    <span id="current-room" class="room-code">----</span>
                    <div class="copy-options">
                        <button id="copy-code" class="icon-btn" title="Copy room code">
                            <i data-lucide="copy" style="width:15px;height:15px;"></i>
                        </button>
                        <button id="copy-link" class="icon-btn" title="Copy room link">
                            <i data-lucide="link-2" style="width:15px;height:15px;"></i>
                        </button>
                    </div>
                </div>

                <div class="header-right">
                    <!-- Chat toggle with unread badge -->
                    <button id="toggle-chat" class="chat-toggle-btn" title="Chat">
                        <i data-lucide="message-circle" style="width:20px;height:20px;"></i>
                        <span id="chat-badge" class="chat-badge">0</span>
                    </button>

                    <div class="participant-pill">
                        <i data-lucide="users" style="width:15px;height:15px;color:#71717a;"></i>
                        <span id="participant-count" class="count">0</span>
                    </div>
                </div>
            </div>

            <div id="video-grid" class="solo">
                <!-- Big spotlight tile -->
                <div id="spotlight-area">
                    <div id="video-grid-empty" class="video-grid-empty-msg">
                        <div class="empty-icon">
                            <i data-lucide="user-plus" style="width:48px;height:48px;"></i>
                        </div>
                        <p>Waiting for others to join…<br>Share the room code with friends</p>
                    </div>
                </div>
                <!-- Thumbnail row (hidden until 2+ people) -->
                <div id="thumbnail-strip" class="hidden"></div>
            </div>

            <div class="call-controls">
                <button id="toggle-mute" class="control-btn active" title="Mute/Unmute">
                    <i data-lucide="mic" style="width:22px;height:22px;"></i>
                    <span>Mic</span>
                </button>
                <button id="toggle-video" class="control-btn active" title="Video on/off">
                    <i data-lucide="video" style="width:22px;height:22px;"></i>
                    <span>Video</span>
                </button>
                <button id="camera-flip" class="control-btn" title="Flip Camera">
                    <i data-lucide="flip-horizontal-2" style="width:22px;height:22px;"></i>
                    <span>Flip</span>
                </button>
                <button id="leave-call" class="control-btn danger" title="Leave call">
                    <i data-lucide="phone-off" style="width:22px;height:22px;color:var(--danger);"></i>
                    <span>Leave</span>
                </button>
            </div>
        </div>
    </div>

    <!-- ─── Chat Panel ─── -->
    <div id="chat-panel" class="chat-panel">
        <div class="chat-header">
            <h3>Chat</h3>
            <button id="close-chat" class="chat-close">
                <i data-lucide="x" style="width:18px;height:18px;"></i>
            </button>
        </div>
        <div id="chat-messages" class="chat-messages"></div>
        <!-- Reply bar shown when replying to a message -->
        <div id="reply-bar" class="reply-bar">
            <div class="reply-bar-content">
                <div id="reply-bar-author" class="reply-bar-author"></div>
                <div id="reply-bar-text" class="reply-bar-text"></div>
            </div>
            <button class="reply-bar-close" id="reply-bar-close" title="Cancel reply">
                <i data-lucide="x" style="width:16px;height:16px;"></i>
            </button>
        </div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="Type a message…" maxlength="500">
            <button id="send-chat">
                <i data-lucide="send" style="width:18px;height:18px;"></i>
            </button>
        </div>
    </div>

    <!-- ─── Loading Overlay ─── -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <p id="loading-message">Connecting…</p>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>

    <script>
    // Init Lucide icons after DOM ready
    document.addEventListener('DOMContentLoaded', () => lucide.createIcons());

    // ─── HTTPS Check ─────────────────────────────────────────────────────────────
    if (
        window.location.protocol !== 'https:' &&
        window.location.hostname !== 'localhost' &&
        !window.location.hostname.includes('127.0.0.1')
    ) {
        document.getElementById('https-warning').classList.add('show');
    }

    // ─── Firebase Config ──────────────────────────────────────────────────────────
    const firebaseConfig = {
        apiKey: "AIzaSyDTRGf1kGE2_Kjm457NmRdID0_w_x5h48k",
        authDomain: "video-9335.firebaseapp.com",
        databaseURL: "https://video-9335-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "video-9335",
        storageBucket: "video-9335.firebasestorage.app",
        messagingSenderId: "438743646214",
        appId: "1:438743646214:web:db16a9d5c94820845b8387"
    };

    let database;
    try {
        firebase.initializeApp(firebaseConfig);
        database = firebase.database();
    } catch (e) { console.error('Firebase init error:', e); }

    // ─── App ─────────────────────────────────────────────────────────────────────
    class VideoCallApp {
        constructor() {
            this.localStream = null;
            this.peers = new Map();
            this.roomId = null;
            this.userId = this.getOrCreateUserId();
            this.isAudioMuted = false;
            this.isVideoMuted = false;
            this.isInitialized = false;
            this.chatMessages = [];
            this.connectionQuality = new Map();
            this.currentFacingMode = 'user';
            this.hasFrontAndBack = false;

            // Chat notifications
            this.unreadCount = 0;
            this.chatOpen = false;

            // Stream monitoring
            this.streamHealthInterval = null;
            this.streamHealthy = true;
            this.reconnectAttempts = 0;
            this.maxReconnectAttempts = 3;
            this.reconnectTimeout = null;
            this.qualityIntervals = new Map();
            this.firebaseListeners = [];

            this.initializeElements();
            this.attachEvents();
            this.checkUrlForRoom();
            this.setupConnectionMonitoring();
            this.checkForActiveSession();
            this.loadUserPreferences();
            this.detectCameraCount();
        }

        // ── Camera detection ─────────────────────────────────────────────────────
        async detectCameraCount() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(d => d.kind === 'videoinput');
                this.hasFrontAndBack = videoDevices.length >= 2;
                // Also show flip on mobile even with 1 camera (user/env switch via facingMode)
                const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
                if (isMobile) {
                    this.hasFrontAndBack = true;
                }
            } catch (e) {
                console.warn('Could not enumerate devices:', e);
            }
        }

        // ── Cookie helpers ────────────────────────────────────────────────────────
        buildCookieOptions(expiry) {
            const isSecure = window.location.protocol === 'https:' &&
                window.location.hostname !== 'localhost' &&
                !window.location.hostname.includes('127.0.0.1');
            return `expires=${expiry.toUTCString()}; path=/; SameSite=Strict${isSecure ? '; Secure' : ''}`;
        }

        getOrCreateUserId() {
            const cookieName = 'video_call_user_id';
            for (let cookie of document.cookie.split(';')) {
                const [name, value] = cookie.trim().split('=');
                if (name === cookieName && value) return value;
            }
            const newId = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            const expiry = new Date(); expiry.setDate(expiry.getDate() + 30);
            document.cookie = `${cookieName}=${newId}; ${this.buildCookieOptions(expiry)}`;
            return newId;
        }

        checkForActiveSession() {
            for (let cookie of document.cookie.split(';')) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'video_call_active_room') {
                    try {
                        const s = JSON.parse(decodeURIComponent(value));
                        if (Date.now() - s.timestamp < 5 * 60 * 1000 && s.roomId) {
                            this.roomInput.value = s.roomId;
                            this.showToast('Previous session detected. Click Join to reconnect.');
                        } else { this.clearSessionCookie(); }
                    } catch (e) {}
                    break;
                }
            }
        }

        setActiveSession(roomId) {
            const d = { roomId, userId: this.userId, timestamp: Date.now() };
            const expiry = new Date(); expiry.setHours(expiry.getHours() + 1);
            document.cookie = `video_call_active_room=${encodeURIComponent(JSON.stringify(d))}; ${this.buildCookieOptions(expiry)}`;
            localStorage.setItem('video_call_active_session', JSON.stringify(d));
        }

        clearUserCookies() {
            for (let cookie of document.cookie.split(';')) {
                const [name] = cookie.trim().split('=');
                if (name.startsWith('video_call_')) {
                    document.cookie = `${name}=; ${this.buildCookieOptions(new Date(0))}`;
                }
            }
            ['video_call_active_session','video_call_user_preferences','video_call_chat_history'].forEach(k => localStorage.removeItem(k));
            sessionStorage.clear();
        }

        clearSessionCookie() {
            document.cookie = `video_call_active_room=; ${this.buildCookieOptions(new Date(0))}`;
            localStorage.removeItem('video_call_active_session');
        }

        saveUserPreferences() {
            const p = { audioMuted: this.isAudioMuted, videoMuted: this.isVideoMuted, lastRoom: this.roomId, timestamp: Date.now() };
            localStorage.setItem('video_call_user_preferences', JSON.stringify(p));
        }

        loadUserPreferences() {
            // NOTE: We intentionally do NOT restore isAudioMuted from prefs.
            // Starting a call muted is confusing and caused audio transmission bugs
            // (the app state said muted but the WebRTC sender was never silenced at join time).
            // Always start with mic ON. Video muted pref is safe to restore.
            try {
                const p = JSON.parse(localStorage.getItem('video_call_user_preferences') || 'null');
                if (p && Date.now() - p.timestamp < 7 * 86400000) {
                    this.isAudioMuted = false; // Always start unmuted
                    this.isVideoMuted = p.videoMuted || false;
                }
            } catch (e) {}
        }

        // ── DOM ────────────────────────────────────────────────────────────────────
        initializeElements() {
            this.landingPage = document.getElementById('landing-page');
            this.callPage = document.getElementById('call-page');
            this.createBtn = document.getElementById('create-room');
            this.joinBtn = document.getElementById('join-room');
            this.roomInput = document.getElementById('room-code-input');
            this.currentRoom = document.getElementById('current-room');
            this.copyCodeBtn = document.getElementById('copy-code');
            this.copyLinkBtn = document.getElementById('copy-link');
            this.videoGrid = document.getElementById('video-grid');
            this.spotlightArea = document.getElementById('spotlight-area');
            this.thumbnailStrip = document.getElementById('thumbnail-strip');
            this.videoGridEmpty = document.getElementById('video-grid-empty');
            this.participantCount = document.getElementById('participant-count');
            this.loadingOverlay = document.getElementById('loading-overlay');
            this.loadingMessage = document.getElementById('loading-message');
            this.reconnectBtn = document.getElementById('reconnect-btn'); // no longer in DOM, kept for safety
            this.muteBtn = document.getElementById('toggle-mute');
            this.videoBtn = document.getElementById('toggle-video');
            this.cameraFlipBtn = document.getElementById('camera-flip');
            this.leaveBtn = document.getElementById('leave-call');
            this.chatPanel = document.getElementById('chat-panel');
            this.toggleChatBtn = document.getElementById('toggle-chat');
            this.closeChatBtn = document.getElementById('close-chat');
            this.chatInput = document.getElementById('chat-input');
            this.sendChatBtn = document.getElementById('send-chat');
            this.chatMessagesContainer = document.getElementById('chat-messages');
            this.chatBadge = document.getElementById('chat-badge');
            // Reply state
            this.replyBar = document.getElementById('reply-bar');
            this.replyBarAuthor = document.getElementById('reply-bar-author');
            this.replyBarText = document.getElementById('reply-bar-text');
            this.replyBarClose = document.getElementById('reply-bar-close');
            this.replyingTo = null; // { text, author } when replying
            // Track active action menu so we can close it on outside click
            this._activeActionMenu = null;
            // Track which container is spotlighted
            this.spotlightedId = null;
        }

        attachEvents() {
            this.createBtn.addEventListener('click', () => this.createRoom());
            this.joinBtn.addEventListener('click', () => this.joinRoom());
            this.copyCodeBtn.addEventListener('click', () => this.copyRoomCode());
            this.copyLinkBtn.addEventListener('click', () => this.copyRoomLink());
            this.muteBtn.addEventListener('click', () => this.toggleAudio());
            this.videoBtn.addEventListener('click', () => this.toggleVideo());
            this.cameraFlipBtn.addEventListener('click', () => this.flipCamera());
            this.leaveBtn.addEventListener('click', () => this.leaveCall());
            this.toggleChatBtn.addEventListener('click', () => this.toggleChat());
            this.closeChatBtn.addEventListener('click', () => this.toggleChat());
            this.sendChatBtn.addEventListener('click', () => this.sendMessage());
            this.chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') this.sendMessage(); });
            this.roomInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') this.joinRoom(); });
            this.roomInput.addEventListener('input', (e) => { e.target.value = e.target.value.replace(/\D/g, ''); });
            // Reply bar close
            this.replyBarClose.addEventListener('click', () => this.clearReply());
            // Dismiss action menu on outside click
            document.addEventListener('click', (e) => {
                if (this._activeActionMenu && !this._activeActionMenu.contains(e.target)) {
                    this._activeActionMenu.classList.remove('show');
                    this._activeActionMenu = null;
                }
            }, true);
        }

        setupConnectionMonitoring() {
            if (!database) return;
            let _fbReconnectTimer = null;
            database.ref('.info/connected').on('value', (snap) => {
                if (snap.val()) {
                    // Connected — cancel any pending reconnect timer
                    if (_fbReconnectTimer) { clearTimeout(_fbReconnectTimer); _fbReconnectTimer = null; }
                    console.log('✅ Firebase connected');
                } else {
                    console.warn('⚠️ Firebase disconnected — will auto-reconnect silently');
                    // Firebase SDK reconnects automatically. If still down after 8s, log only.
                    _fbReconnectTimer = setTimeout(() => {
                        console.warn('Firebase still reconnecting…');
                    }, 8000);
                }
            });
        }

        checkUrlForRoom() {
            const params = new URLSearchParams(window.location.search);
            const room = params.get('room');
            if (room && /^\d{4}$/.test(room)) {
                this.roomInput.value = room;
                setTimeout(() => this.joinRoom(), 500);
            }
        }

        updateUrl(roomCode) {
            const url = new URL(window.location);
            url.searchParams.set('room', roomCode);
            window.history.pushState({}, '', url);
        }

        showToast(message, important = false) {
            const duration = important ? 5000 : 2500;
            const toast = document.createElement('div');
            toast.className = 'toast' + (important ? ' toast-important' : '');
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), duration);
        }

        showLoading(show, message = 'Connecting…') {
            this.loadingMessage.textContent = message;
            this.loadingOverlay.style.display = show ? 'flex' : 'none';
        }

        // Silent no-ops — reconnection is fully automatic, no UI banner
        showReconnectionBanner(message) { console.warn('Stream event (auto-recovering):', message); }
        hideReconnectionBanner() {}

        // ── Grid layout manager ───────────────────────────────────────────────────
        // Collect all participant IDs (local + remote) currently rendered
        getAllParticipantIds() {
            const ids = [this.userId];
            this.peers.forEach((_, id) => ids.push(id));
            return ids;
        }

        // Move a container clone into the spotlight; original stays in thumbnail strip
        setSpotlight(targetId, fromJoin = false) {
            const container = document.getElementById(`container-${targetId}`);
            if (!container) return;

            this.spotlightedId = targetId;

            // Clear any previous spotlight keepalive
            if (this._spotlightSyncInterval) {
                clearInterval(this._spotlightSyncInterval);
                this._spotlightSyncInterval = null;
            }

            // Clear spotlight area (keep empty msg node)
            Array.from(this.spotlightArea.children).forEach(c => {
                if (!c.classList.contains('video-grid-empty-msg')) c.remove();
            });

            // Clone into spotlight
            const clone = container.cloneNode(true);
            clone.id = `spotlight-clone-${targetId}`;
            clone.style.cssText = 'width:100%;height:100%;border-radius:0;border:none;box-shadow:none;aspect-ratio:unset;cursor:default;';

            // Sync the live video srcObject to the clone
            const origVideo = container.querySelector('video');
            const cloneVideo = clone.querySelector('video');
            if (origVideo && cloneVideo) {
                cloneVideo.srcObject = origVideo.srcObject;
                // CRITICAL: local video ALWAYS muted — never play your own mic back
                const isLocal = (targetId === this.userId);
                cloneVideo.muted = isLocal;
                cloneVideo.volume = isLocal ? 0 : 1;
                cloneVideo.autoplay = true;
                cloneVideo.playsInline = true;
            }

            this.spotlightArea.appendChild(clone);

            // Play the clone video
            if (cloneVideo) {
                cloneVideo.play().catch(() => {});
            }

            // ── Freeze prevention: periodically re-sync srcObject & kick play() ──
            // The spotlight clone video can freeze because its srcObject is a copy
            // of the stream reference — if the underlying track changes (flip camera,
            // reinitialize) the clone won't auto-update. We sync every 3s.
            this._spotlightSyncInterval = setInterval(() => {
                const src = container.querySelector('video');
                const dst = document.getElementById(`spotlight-clone-${targetId}`)?.querySelector('video');
                if (!src || !dst) { clearInterval(this._spotlightSyncInterval); return; }

                // Re-sync srcObject if it drifted
                if (dst.srcObject !== src.srcObject) {
                    dst.srcObject = src.srcObject;
                    const isLocal = (targetId === this.userId);
                    dst.muted = isLocal;
                    dst.volume = isLocal ? 0 : 1;
                    dst.play().catch(() => {});
                }

                // Detect freeze: readyState should be HAVE_ENOUGH_DATA (4)
                // If it's stuck and paused, kick it
                if (dst.paused && dst.readyState >= 2) {
                    dst.play().catch(() => {});
                }
            }, 3000);

            // Mark active thumbnail
            this.thumbnailStrip.querySelectorAll('.video-container').forEach(c => c.classList.remove('thumbnail-active'));
            container.classList.add('thumbnail-active');

            lucide.createIcons();
        }

        updateGridLayout() {
            const allIds = this.getAllParticipantIds();
            const total = allIds.length;

            // Hide empty state - always show something when we're in a call
            this.videoGridEmpty.classList.remove('show');

            // Solo mode: just local in spotlight, no strip
            if (total === 1) {
                this.videoGrid.classList.add('solo');
                this.thumbnailStrip.classList.add('hidden');
                // Local video goes directly in spotlight
                this.setSpotlight(this.userId);
                return;
            }

            // Multi-person: strip + spotlight
            this.videoGrid.classList.remove('solo');
            this.thumbnailStrip.classList.remove('hidden');

            // Make sure all containers are in the thumbnail strip
            allIds.forEach(id => {
                const container = document.getElementById(`container-${id}`);
                if (container && container.parentElement !== this.thumbnailStrip) {
                    this.thumbnailStrip.appendChild(container);
                }
            });

            // If no one is spotlighted yet, randomly pick one
            if (!this.spotlightedId || !allIds.includes(this.spotlightedId)) {
                const randomId = allIds[Math.floor(Math.random() * allIds.length)];
                this.setSpotlight(randomId, true);
            } else {
                // Re-sync spotlight clone srcObject (stream may have changed)
                this.setSpotlight(this.spotlightedId);
            }
        }

        updateEmptyState() {
            // Called by old code paths — just delegate to updateGridLayout
            this.updateGridLayout();
        }

        // ── Chat notifications ────────────────────────────────────────────────────
        incrementUnread() {
            this.unreadCount++;
            this.chatBadge.textContent = this.unreadCount > 99 ? '99+' : this.unreadCount;
            this.chatBadge.classList.add('show', 'pulse');
            this.toggleChatBtn.classList.add('has-unread');

            // Vibrate on supported devices
            if ('vibrate' in navigator) {
                navigator.vibrate([60, 30, 60]);
            }
        }

        clearUnread() {
            this.unreadCount = 0;
            this.chatBadge.classList.remove('show', 'pulse');
            this.toggleChatBtn.classList.remove('has-unread');
        }

        // ── Room management ───────────────────────────────────────────────────────
        async createRoom() {
            try {
                this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
                this.updateUrl(this.roomId);
                this.currentRoom.textContent = this.roomId;
                this.showLoading(true, 'Creating room…');
                if (database) {
                    await database.ref(`rooms/${this.roomId}`).set({ created: Date.now(), createdBy: this.userId });
                }
                await this.initializeMedia();
                this.landingPage.classList.remove('active');
                this.callPage.classList.add('active');
                this.setupFirebaseListeners();
                this.setActiveSession(this.roomId);
                this.startStreamHealthMonitoring();
                this.isInitialized = true;
                this.showToast(`Room created: ${this.roomId}`);
                setTimeout(() => this.copyRoomCode(), 1000);
            } catch (error) {
                console.error('Error creating room:', error);
                this.showToast('Failed to create room');
            } finally {
                this.showLoading(false);
            }
        }

        async joinRoom() {
            try {
                const roomCode = this.roomInput.value.trim();
                if (!roomCode || !/^\d{4}$/.test(roomCode)) {
                    this.showToast('Please enter a valid 4-digit code');
                    return;
                }
                this.roomId = roomCode;
                this.updateUrl(roomCode);
                this.currentRoom.textContent = roomCode;
                this.showLoading(true, 'Joining room…');
                if (database) {
                    const snap = await database.ref(`rooms/${roomCode}`).once('value');
                    if (!snap.exists()) await database.ref(`rooms/${roomCode}`).set({ created: Date.now(), createdBy: this.userId });
                }
                await this.initializeMedia();
                this.landingPage.classList.remove('active');
                this.callPage.classList.add('active');
                this.setupFirebaseListeners();
                this.setActiveSession(roomCode);
                this.startStreamHealthMonitoring();
                this.isInitialized = true;
                this.showToast(`Joined room: ${roomCode}`);
            } catch (error) {
                console.error('Error joining room:', error);
                this.showToast('Failed to join room');
            } finally {
                this.showLoading(false);
            }
        }

        // ── Media ─────────────────────────────────────────────────────────────────
        async initializeMedia() {
            const constraints = {
                video: { width: { ideal: 1280, max: 1920 }, height: { ideal: 720, max: 1080 }, facingMode: this.currentFacingMode },
                audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
            };
            try {
                this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (err) {
                console.warn('HD failed, trying basic:', err);
                this.localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            }
            if (!this.localStream) { this.showToast('Camera and microphone access required'); throw new Error('No stream'); }

            // Always start with audio ON — stash the real track reference
            this._realAudioTrack = this.localStream.getAudioTracks()[0] || null;
            this.isAudioMuted = false; // always start unmuted

            const vTrack = this.localStream.getVideoTracks()[0];
            if (this._realAudioTrack) this._realAudioTrack.enabled = true;
            if (vTrack) vTrack.enabled = !this.isVideoMuted;

            this.localStream.getTracks().forEach(t => {
                t.onended = () => this.handleTrackEnded(t.kind);
            });
            this.addLocalVideo();
        }

        // ── Camera flip ───────────────────────────────────────────────────────────
        async flipCamera() {
            if (!this.localStream) return;
            // Only toggle between front and back
            const newFacingMode = this.currentFacingMode === 'user' ? 'environment' : 'user';
            try {
                this.showLoading(true, newFacingMode === 'environment' ? 'Switching to back camera…' : 'Switching to front camera…');

                const newStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { exact: newFacingMode }, width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                }).catch(() => navigator.mediaDevices.getUserMedia({
                    // Fallback without exact constraint (desktop / some browsers)
                    video: { facingMode: newFacingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                }));

                const aTrack = newStream.getAudioTracks()[0];
                const vTrack = newStream.getVideoTracks()[0];

                // Update the stored real audio track reference
                if (aTrack) {
                    this._realAudioTrack = aTrack;
                    aTrack.enabled = !this.isAudioMuted;
                }
                if (vTrack) vTrack.enabled = !this.isVideoMuted;

                // Stop old video tracks only
                this.localStream.getVideoTracks().forEach(t => t.stop());

                // Update mirror class on local container
                const localContainer = document.getElementById(`container-${this.userId}`);
                if (localContainer) {
                    localContainer.classList.remove('cam-front', 'cam-back');
                    localContainer.classList.add(newFacingMode === 'user' ? 'cam-front' : 'cam-back');
                    const video = localContainer.querySelector('video');
                    if (video) { video.muted = true; video.volume = 0; video.srcObject = newStream; video.play().catch(() => {}); }
                }
                // Also update spotlight clone if local is spotlighted
                const cloneContainer = document.getElementById(`spotlight-clone-${this.userId}`);
                if (cloneContainer) {
                    cloneContainer.classList.remove('cam-front', 'cam-back');
                    cloneContainer.classList.add(newFacingMode === 'user' ? 'cam-front' : 'cam-back');
                    const cv = cloneContainer.querySelector('video');
                    if (cv) { cv.muted = true; cv.volume = 0; cv.srcObject = newStream; cv.play().catch(() => {}); }
                }

                // Replace video track in all peer connections
                this.peers.forEach((peer) => {
                    if (peer && peer._pc) {
                        try {
                            const sender = peer._pc.getSenders().find(s => s.track && s.track.kind === 'video');
                            if (sender) sender.replaceTrack(newStream.getVideoTracks()[0]);
                        } catch (e) { console.error('replaceTrack error:', e); }
                    }
                });

                this.localStream = newStream;
                this.localStream.getTracks().forEach(t => { t.onended = () => this.handleTrackEnded(t.kind); });
                this.currentFacingMode = newFacingMode;

                // Update flip button icon with animation
                const flipIcon = this.cameraFlipBtn.querySelector('i');
                if (flipIcon) {
                    flipIcon.style.transition = 'transform 0.35s cubic-bezier(.22,.68,0,1.2)';
                    flipIcon.style.transform = 'rotateY(180deg) scale(1.2)';
                    setTimeout(() => { flipIcon.style.transform = ''; }, 380);
                }

                this.showToast(newFacingMode === 'user' ? '📷 Front camera' : '📷 Back camera');
            } catch (e) {
                console.error('Camera flip error:', e);
                this.showToast('Could not switch camera — check permissions');
            } finally {
                this.showLoading(false);
            }
        }

        handleTrackEnded(kind) {
            this.showReconnectionBanner(`${kind} stream ended`);
            this.attemptReconnection();
        }

        startStreamHealthMonitoring() {
            if (this.streamHealthInterval) clearInterval(this.streamHealthInterval);
            this.streamHealthInterval = setInterval(() => this.checkStreamHealth(), 10000);
        }

        checkStreamHealth() {
            if (!this.localStream) { this.streamHealthy = false; this.showReconnectionBanner('No stream'); this.attemptReconnection(); return; }
            const vTrack = this.localStream.getVideoTracks()[0];
            const aTrack = this.localStream.getAudioTracks()[0];
            const vOk = !vTrack || vTrack.readyState === 'live';
            const aOk = !aTrack || aTrack.readyState === 'live';
            if (!vOk || !aOk) {
                this.streamHealthy = false;
                this.showReconnectionBanner('Stream quality degraded');
                this.attemptReconnection();
            } else {
                this.streamHealthy = true;
                this.hideReconnectionBanner();
                this.reconnectAttempts = 0;
            }
        }

        async attemptReconnection() {
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                this.showToast('Unable to recover stream. Please refresh.', true); return;
            }
            this.reconnectAttempts++;
            if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = setTimeout(async () => {
                try { await this.reinitializeMedia(); } catch (e) { this.attemptReconnection(); }
            }, 2000 * this.reconnectAttempts);
        }

        async forceReconnect() {
            this.showLoading(true, 'Reconnecting…');
            this.reconnectAttempts = 0;
            await this.reinitializeMedia();
            this.showLoading(false);
        }

        async reinitializeMedia() {
            if (this.localStream) this.localStream.getTracks().forEach(t => { try { t.stop(); } catch (e) {} });
            const newStream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 1280, max: 1920 }, height: { ideal: 720, max: 1080 }, facingMode: this.currentFacingMode },
                audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
            });
            const aT = newStream.getAudioTracks()[0];
            const vT = newStream.getVideoTracks()[0];

            // Always reinitialize with audio ON — update stored real track ref
            this._realAudioTrack = aT || null;
            this.isAudioMuted = false;
            if (aT) aT.enabled = true;
            if (vT) vT.enabled = !this.isVideoMuted;
            newStream.getTracks().forEach(t => { t.onended = () => this.handleTrackEnded(t.kind); });

            const lc = document.getElementById(`container-${this.userId}`);
            if (lc) {
                // Maintain correct mirror class
                lc.classList.remove('cam-front', 'cam-back');
                lc.classList.add(this.currentFacingMode === 'user' ? 'cam-front' : 'cam-back');
                const v = lc.querySelector('video');
                if (v) { v.muted = true; v.volume = 0; v.srcObject = newStream; v.play().catch(e => {}); }
            }
            // Sync spotlight clone if local is spotlighted
            const lclone = document.getElementById(`spotlight-clone-${this.userId}`);
            if (lclone) {
                lclone.classList.remove('cam-front', 'cam-back');
                lclone.classList.add(this.currentFacingMode === 'user' ? 'cam-front' : 'cam-back');
                const cv = lclone.querySelector('video');
                if (cv) { cv.muted = true; cv.volume = 0; cv.srcObject = newStream; cv.play().catch(() => {}); }
            }

            this.peers.forEach((peer, peerId) => {
                if (peer && peer._pc) {
                    try {
                        newStream.getTracks().forEach(t => {
                            const s = peer._pc.getSenders().find(s => s.track && s.track.kind === t.kind);
                            if (s) s.replaceTrack(t);
                        });
                    } catch (e) { this.reconnectPeer(peerId); }
                }
            });
            this.localStream = newStream;
            this.streamHealthy = true; this.hideReconnectionBanner();
            this.showToast('Stream recovered');
        }

        reconnectPeer(peerId) {
            const old = this.peers.get(peerId);
            if (old) { try { old.destroy(); } catch (e) {} this.peers.delete(peerId); this.connectionQuality.delete(peerId); }
            if (this.qualityIntervals.has(peerId)) { clearInterval(this.qualityIntervals.get(peerId)); this.qualityIntervals.delete(peerId); }
            const clone = document.getElementById(`spotlight-clone-${peerId}`);
            if (clone) clone.remove();
            const c = document.getElementById(`container-${peerId}`);
            if (c) c.remove();
            if (this.spotlightedId === peerId) this.spotlightedId = null;
            this.updateGridLayout();
            setTimeout(() => this.connectToPeer(peerId, true), 1000);
        }

        // ── Local video ───────────────────────────────────────────────────────────
        addLocalVideo() {
            // Remove any previous local container
            const prev = document.getElementById(`container-${this.userId}`);
            if (prev) prev.remove();

            const container = document.createElement('div');
            // Use cam-front by default (front camera mirrors)
            container.className = 'video-container local-video cam-front' + (this.isVideoMuted ? ' video-off' : '');
            container.id = `container-${this.userId}`;

            const video = document.createElement('video');
            video.srcObject = this.localStream;
            video.autoplay = true;
            video.playsInline = true;
            video.muted = true;      // Prevent hearing your own mic through speakers
            video.volume = 0;        // Belt-and-suspenders: some browsers ignore muted on dynamic elements

            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.innerHTML = `<i data-lucide="user" style="width:40%;height:40%;opacity:0.3;"></i>`;

            const name = document.createElement('span');
            name.className = 'participant-name'; name.textContent = 'You';

            const audioIndicator = document.createElement('div');
            audioIndicator.className = 'audio-indicator' + (this.isAudioMuted ? ' muted' : '');
            audioIndicator.innerHTML = this.isAudioMuted
                ? `<i data-lucide="mic-off" style="width:16px;height:16px;"></i>`
                : `<i data-lucide="mic" style="width:16px;height:16px;"></i>`;

            const pipBtn = document.createElement('button');
            pipBtn.className = 'pip-btn';
            pipBtn.innerHTML = `<i data-lucide="picture-in-picture-2" style="width:16px;height:16px;"></i>`;
            pipBtn.onclick = (e) => { e.stopPropagation(); this.togglePiP(video); };

            container.appendChild(video);
            container.appendChild(avatar);
            container.appendChild(name);
            container.appendChild(audioIndicator);
            container.appendChild(pipBtn);

            // Click thumbnail to spotlight
            container.addEventListener('click', () => this.setSpotlight(this.userId));

            // Put into thumbnail strip temporarily; grid layout will move it
            this.thumbnailStrip.appendChild(container);

            this.muteBtn.classList.toggle('active', !this.isAudioMuted);
            this.videoBtn.classList.toggle('active', !this.isVideoMuted);

            video.play().catch(e => console.error('Local video error:', e.name));
            lucide.createIcons();
            this.updateGridLayout();
        }

        togglePiP(videoEl) {
            if (document.pictureInPictureElement) {
                document.exitPictureInPicture().then(() => this.showToast('Exited PiP')).catch(() => {});
            } else {
                videoEl.requestPictureInPicture().then(() => this.showToast('PiP enabled')).catch(() => this.showToast('PiP not supported'));
            }
        }

        // ── Connection quality ────────────────────────────────────────────────────
        async measureConnectionQuality(peer, peerId) {
            if (!peer || !peer._pc) return;
            try {
                const stats = await peer._pc.getStats();
                let packetsLost = 0, packetsTotal = 0, rttMs = null;
                stats.forEach(r => {
                    if (r.type === 'inbound-rtp' && r.mediaType === 'video') {
                        packetsLost += r.packetsLost || 0;
                        packetsTotal += (r.packetsReceived || 0) + (r.packetsLost || 0);
                    }
                    if (r.type === 'candidate-pair' && r.state === 'succeeded' && r.currentRoundTripTime != null) {
                        rttMs = r.currentRoundTripTime * 1000;
                    }
                });
                const loss = packetsTotal > 0 ? packetsLost / packetsTotal : 0;
                let quality;
                if (rttMs !== null) {
                    quality = rttMs < 100 && loss < 0.01 ? 4 : rttMs < 200 && loss < 0.03 ? 3 : rttMs < 400 && loss < 0.08 ? 2 : 1;
                } else {
                    quality = loss < 0.03 ? 3 : loss < 0.08 ? 2 : 1;
                }
                this.updateConnectionQuality(peerId, quality);
            } catch (e) {}
        }

        updateConnectionQuality(peerId, quality) {
            this.connectionQuality.set(peerId, quality);
            const container = document.getElementById(`container-${peerId}`);
            if (!container) return;
            let indicator = container.querySelector('.connection-quality');
            if (!indicator) { indicator = document.createElement('div'); indicator.className = 'connection-quality'; container.appendChild(indicator); }
            const cls = quality <= 1 ? 'poor' : quality === 2 ? 'fair' : '';
            indicator.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const bar = document.createElement('span');
                bar.className = 'quality-bar' + (i < quality ? ' active' + (cls ? ' ' + cls : '') : '');
                indicator.appendChild(bar);
            }
        }

        // ── Firebase ──────────────────────────────────────────────────────────────
        setupFirebaseListeners() {
            if (!database || !this.roomId) return;
            const roomRef = database.ref(`rooms/${this.roomId}`);
            const participantsRef = roomRef.child('participants');
            const messagesRef = roomRef.child('messages');
            const signalsRef = database.ref(`rooms/${this.roomId}/signals`);

            const onPA = participantsRef.on('child_added', (snap) => {
                const pid = snap.key;
                if (pid !== this.userId && !this.peers.has(pid) && this.localStream) {
                    setTimeout(() => { if (!this.peers.has(pid)) this.connectToPeer(pid, true); }, Math.random() * 1000 + 500);
                }
                this.updateParticipantCount(roomRef);
            });
            const onPR = participantsRef.on('child_removed', (snap) => {
                this.removeParticipant(snap.key);
                this.updateParticipantCount(roomRef);
                this.checkAndCleanupRoom(roomRef);
            });
            const onMsg = messagesRef.on('child_added', (snap) => {
                const msg = snap.val();
                this.displayMessage(msg);
                // Show unread badge if chat is closed and message is from others
                if (!this.chatOpen && msg.from !== this.userId) {
                    this.incrementUnread();
                }
            });
            const onSig = signalsRef.on('child_added', (snap) => {
                const sig = snap.val();
                if (sig && sig.target === this.userId && sig.from !== this.userId) this.handleSignal(sig);
                setTimeout(() => snap.ref.remove(), 30000);
            });

            this.firebaseListeners = [
                { ref: participantsRef, event: 'child_added', fn: onPA },
                { ref: participantsRef, event: 'child_removed', fn: onPR },
                { ref: messagesRef, event: 'child_added', fn: onMsg },
                { ref: signalsRef, event: 'child_added', fn: onSig }
            ];

            const selfRef = participantsRef.child(this.userId);
            selfRef.set({ timestamp: Date.now(), userId: this.userId });
            selfRef.onDisconnect().remove();
            this.updateParticipantCount(roomRef);
        }

        tearDownFirebaseListeners() {
            this.firebaseListeners.forEach(({ ref, event, fn }) => { try { ref.off(event, fn); } catch (e) {} });
            this.firebaseListeners = [];
        }

        updateParticipantCount(roomRef) {
            roomRef.child('participants').once('value', (snap) => {
                const count = snap.val() ? Object.keys(snap.val()).length : 0;
                this.participantCount.textContent = count;
            });
        }

        checkAndCleanupRoom(roomRef) {
            roomRef.child('participants').once('value', (snap) => {
                if (!snap.exists() || snap.numChildren() === 0) roomRef.remove().catch(() => {});
            });
        }

        // ── Peers ─────────────────────────────────────────────────────────────────
        connectToPeer(peerId, initiator = false) {
            if (this.peers.has(peerId)) return;
            if (!this.localStream) {
                setTimeout(() => { if (!this.peers.has(peerId) && this.localStream) this.connectToPeer(peerId, initiator); }, 1000); return;
            }
            try {
                const peer = new SimplePeer({
                    initiator, stream: this.localStream, trickle: true,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' }
                        ]
                    }
                });
                peer.on('signal', (signal) => {
                    if (database && this.roomId) database.ref(`rooms/${this.roomId}/signals`).push({ from: this.userId, target: peerId, signal, timestamp: Date.now() });
                });
                peer.on('stream', (stream) => this.addRemoteVideo(stream, peerId));
                peer.on('close', () => this.removeParticipant(peerId));
                peer.on('error', (err) => { setTimeout(() => { if (this.roomId && this.localStream) this.reconnectPeer(peerId); }, 2000); });
                peer.on('connect', () => {
                    this.reconnectAttempts = 0;
                    const qInterval = setInterval(() => this.measureConnectionQuality(peer, peerId), 5000);
                    this.qualityIntervals.set(peerId, qInterval);
                });
                peer.on('iceStateChange', (state) => {
                    if (state === 'failed' || state === 'disconnected') {
                        setTimeout(() => { if (this.roomId && this.localStream && !this.peers.has(peerId)) this.reconnectPeer(peerId); }, 3000);
                    }
                });
                this.peers.set(peerId, peer);
            } catch (e) { console.error('Error creating peer:', e); }
        }

        handleSignal(signal) {
            const from = signal.from;
            if (!this.peers.has(from)) {
                this.connectToPeer(from, false);
                let attempts = 0;
                const trySignal = () => {
                    const peer = this.peers.get(from);
                    if (peer) { try { peer.signal(signal.signal); } catch (e) {} }
                    else if (attempts < 6) { attempts++; setTimeout(trySignal, 500); }
                };
                setTimeout(trySignal, 200);
            } else {
                try { this.peers.get(from).signal(signal.signal); } catch (e) {}
            }
        }

        // ── Remote video ──────────────────────────────────────────────────────────
        addRemoteVideo(stream, userId) {
            const existing = document.getElementById(`container-${userId}`);
            if (existing) {
                // Update srcObject if stream changed
                const v = existing.querySelector('video');
                if (v && v.srcObject !== stream) { v.srcObject = stream; v.play().catch(() => {}); }
                // Also sync spotlight clone if this user is spotlighted
                const clone = document.getElementById(`spotlight-clone-${userId}`);
                if (clone) {
                    const cv = clone.querySelector('video');
                    if (cv) cv.srcObject = stream;
                }
                return;
            }

            const container = document.createElement('div');
            container.className = 'video-container'; container.id = `container-${userId}`;

            const video = document.createElement('video');
            video.srcObject = stream; video.autoplay = true; video.playsInline = true;

            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.innerHTML = `<i data-lucide="user" style="width:40%;height:40%;opacity:0.3;"></i>`;

            const name = document.createElement('span');
            name.className = 'participant-name'; name.textContent = `User ${userId.substr(-4)}`;

            const audioIndicator = document.createElement('div');
            audioIndicator.className = 'audio-indicator';
            audioIndicator.innerHTML = `<i data-lucide="mic" style="width:16px;height:16px;"></i>`;

            const qualityIndicator = document.createElement('div');
            qualityIndicator.className = 'connection-quality';
            for (let i = 0; i < 4; i++) {
                const bar = document.createElement('span'); bar.className = 'quality-bar';
                qualityIndicator.appendChild(bar);
            }

            container.appendChild(video); container.appendChild(avatar); container.appendChild(name);
            container.appendChild(audioIndicator); container.appendChild(qualityIndicator);

            // Click thumbnail to spotlight this user
            container.addEventListener('click', () => this.setSpotlight(userId));

            this.thumbnailStrip.appendChild(container);

            // Randomly spotlight either new joiner or keep current — 50/50 if someone else is already spotlighted
            const shouldSpotlight = !this.spotlightedId || Math.random() < 0.5;
            if (shouldSpotlight) {
                this.spotlightedId = userId; // will be set by updateGridLayout
            }

            lucide.createIcons();
            video.play().catch(() => { setTimeout(() => video.play().catch(() => {}), 1000); });
            this.updateGridLayout();
        }

        removeParticipant(userId) {
            const peer = this.peers.get(userId);
            if (peer) { try { peer.destroy(); } catch (e) {} this.peers.delete(userId); this.connectionQuality.delete(userId); }
            if (this.qualityIntervals.has(userId)) { clearInterval(this.qualityIntervals.get(userId)); this.qualityIntervals.delete(userId); }

            // Remove spotlight clone
            const clone = document.getElementById(`spotlight-clone-${userId}`);
            if (clone) clone.remove();

            // Remove thumbnail container
            const c = document.getElementById(`container-${userId}`);
            if (c) c.remove();

            // If this was the spotlighted user, pick a new one
            if (this.spotlightedId === userId) {
                this.spotlightedId = null;
            }

            this.updateGridLayout();
        }

        // ── Controls ──────────────────────────────────────────────────────────────

        // Creates a guaranteed-silent audio track via AudioContext
        _createSilentAudioTrack() {
            try {
                if (this._silentAudio) return this._silentAudio; // reuse
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const dest = ctx.createMediaStreamDestination();
                // A gain node with gain=0 produces true silence
                const gain = ctx.createGain();
                gain.gain.value = 0;
                const osc = ctx.createOscillator();
                osc.connect(gain);
                gain.connect(dest);
                osc.start();
                const silentTrack = dest.stream.getAudioTracks()[0];
                this._silentAudio = { track: silentTrack, ctx };
                return this._silentAudio;
            } catch (e) {
                console.warn('AudioContext unavailable:', e);
                return null;
            }
        }

        toggleAudio() {
            if (!this.localStream) return;

            // Use the stored real track — NOT localStream.getAudioTracks()[0]
            // because after replaceTrack, the stream's track list may have changed
            const realTrack = this._realAudioTrack;
            if (!realTrack) {
                // Fallback: grab from stream
                const tracks = this.localStream.getAudioTracks();
                if (!tracks.length) return;
                this._realAudioTrack = tracks[0];
            }

            this.isAudioMuted = !this.isAudioMuted;

            if (this.isAudioMuted) {
                // 1. Disable the real track locally
                this._realAudioTrack.enabled = false;

                // 2. Replace with silent track in ALL peer senders
                const silent = this._createSilentAudioTrack();
                this.peers.forEach((peer) => {
                    if (!peer || !peer._pc) return;
                    const sender = peer._pc.getSenders().find(s => s.track && s.track.kind === 'audio');
                    if (!sender) return;
                    if (silent) {
                        sender.replaceTrack(silent.track).catch(e => {
                            console.warn('replaceTrack (mute) failed, disabling track:', e);
                            if (this._realAudioTrack) this._realAudioTrack.enabled = false;
                        });
                    } else {
                        if (sender.track) sender.track.enabled = false;
                    }
                });
            } else {
                // 1. Re-enable the real track
                this._realAudioTrack.enabled = true;

                // 2. Restore real track in ALL peer senders
                this.peers.forEach((peer) => {
                    if (!peer || !peer._pc) return;
                    const sender = peer._pc.getSenders().find(s => s.track && s.track.kind === 'audio');
                    if (!sender) return;
                    sender.replaceTrack(this._realAudioTrack).catch(e => {
                        console.warn('replaceTrack (unmute) failed, enabling track:', e);
                        if (this._realAudioTrack) this._realAudioTrack.enabled = true;
                    });
                });
            }

            // Update UI indicators
            const updateIndicator = (container) => {
                if (!container) return;
                const ind = container.querySelector('.audio-indicator');
                if (!ind) return;
                ind.classList.toggle('muted', this.isAudioMuted);
                ind.innerHTML = this.isAudioMuted
                    ? `<i data-lucide="mic-off" style="width:16px;height:16px;"></i>`
                    : `<i data-lucide="mic" style="width:16px;height:16px;"></i>`;
            };
            updateIndicator(document.getElementById(`container-${this.userId}`));
            updateIndicator(document.getElementById(`spotlight-clone-${this.userId}`));
            lucide.createIcons();

            const muteIcon = this.muteBtn.querySelector('i');
            if (muteIcon) { muteIcon.setAttribute('data-lucide', this.isAudioMuted ? 'mic-off' : 'mic'); lucide.createIcons(); }
            this.muteBtn.classList.toggle('active', !this.isAudioMuted);
            const muteLabel = this.muteBtn.querySelector('span');
            if (muteLabel) muteLabel.textContent = this.isAudioMuted ? 'Unmute' : 'Mic';

            this.saveUserPreferences();
            this.showToast(this.isAudioMuted ? '🔇 Microphone muted' : '🎙️ Microphone on');
        }

        toggleVideo() {
            if (!this.localStream) return;
            const t = this.localStream.getVideoTracks()[0];
            if (!t) return;
            t.enabled = !t.enabled;
            this.isVideoMuted = !t.enabled;
            const c = document.getElementById(`container-${this.userId}`);
            if (c) c.classList.toggle('video-off', this.isVideoMuted);
            const videoIcon = this.videoBtn.querySelector('i');
            if (videoIcon) {
                videoIcon.setAttribute('data-lucide', this.isVideoMuted ? 'video-off' : 'video');
                lucide.createIcons();
            }
            this.videoBtn.classList.toggle('active', !this.isVideoMuted);
            const videoLabel = this.videoBtn.querySelector('span');
            if (videoLabel) videoLabel.textContent = this.isVideoMuted ? 'Start Video' : 'Video';
            this.saveUserPreferences();
            this.showToast(this.isVideoMuted ? 'Video paused' : 'Video resumed');
        }

        toggleChat() {
            this.chatOpen = !this.chatOpen;
            this.chatPanel.classList.toggle('open', this.chatOpen);
            if (this.chatOpen) {
                this.clearUnread();
            } else {
                this.clearReply();
                if (this._activeActionMenu) {
                    this._activeActionMenu.classList.remove('show');
                    this._activeActionMenu = null;
                }
            }
        }

        sendMessage() {
            const text = this.chatInput.value.trim();
            if (!text || !database || !this.roomId) return;
            const message = {
                from: this.userId,
                text,
                timestamp: Date.now(),
                senderName: 'You',
                // Attach reply context if replying
                replyTo: this.replyingTo ? { text: this.replyingTo.text, author: this.replyingTo.author } : null
            };
            database.ref(`rooms/${this.roomId}/messages`).push(message)
                .then(() => {
                    this.chatInput.value = '';
                    this.clearReply();
                })
                .catch(() => this.showToast('Failed to send message'));
        }

        clearReply() {
            this.replyingTo = null;
            this.replyBar.classList.remove('show');
            this.replyBarAuthor.textContent = '';
            this.replyBarText.textContent = '';
        }

        startReply(author, text) {
            this.replyingTo = { author, text };
            this.replyBarAuthor.textContent = `Replying to ${author}`;
            this.replyBarText.textContent = text;
            this.replyBar.classList.add('show');
            this.chatInput.focus();
        }

        displayMessage(message) {
            const isOwn = message.from === this.userId;
            const senderLabel = isOwn ? 'You' : `User ${message.from.substr(-4)}`;
            const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // ── Wrapper ──
            const wrap = document.createElement('div');
            wrap.className = 'chat-message-wrap' + (isOwn ? ' own' : '');

            // ── Action menu (copy + reply) ──
            const actions = document.createElement('div');
            actions.className = 'msg-actions';
            actions.innerHTML = `
                <button class="msg-action-btn reply-btn">
                    <i data-lucide="reply" style="width:14px;height:14px;"></i> Reply
                </button>
                <button class="msg-action-btn copy-btn">
                    <i data-lucide="copy" style="width:14px;height:14px;"></i> Copy
                </button>
            `;

            // ── Bubble ──
            const bubble = document.createElement('div');
            bubble.className = 'chat-message' + (isOwn ? ' own-message' : '');

            // Reply preview (if this message is a reply)
            if (message.replyTo) {
                const preview = document.createElement('div');
                preview.className = 'reply-preview';
                preview.innerHTML = `
                    <div class="reply-author">${this.escapeHtml(message.replyTo.author)}</div>
                    <div class="reply-text">${this.escapeHtml(message.replyTo.text)}</div>
                `;
                bubble.appendChild(preview);
            }

            const senderEl = document.createElement('div');
            senderEl.className = 'message-sender';
            senderEl.textContent = senderLabel;

            const textEl = document.createElement('div');
            textEl.className = 'message-text';
            textEl.textContent = message.text; // textContent auto-escapes

            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            timeEl.textContent = time;

            bubble.appendChild(senderEl);
            bubble.appendChild(textEl);
            bubble.appendChild(timeEl);

            // ── Click bubble → toggle action menu ──
            bubble.addEventListener('click', (e) => {
                e.stopPropagation();
                // Close any other open menu first
                if (this._activeActionMenu && this._activeActionMenu !== actions) {
                    this._activeActionMenu.classList.remove('show');
                }
                const isOpen = actions.classList.contains('show');
                actions.classList.toggle('show', !isOpen);
                this._activeActionMenu = isOpen ? null : actions;
                lucide.createIcons();
            });

            // ── Reply button ──
            actions.querySelector('.reply-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                actions.classList.remove('show');
                this._activeActionMenu = null;
                this.startReply(senderLabel, message.text);
            });

            // ── Copy button ──
            actions.querySelector('.copy-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                actions.classList.remove('show');
                this._activeActionMenu = null;
                this.copyToClipboard(message.text, '✅ Message copied!');
            });

            wrap.appendChild(actions);
            wrap.appendChild(bubble);
            this.chatMessagesContainer.appendChild(wrap);
            this.chatMessagesContainer.scrollTop = this.chatMessagesContainer.scrollHeight;
            lucide.createIcons();
        }

        escapeHtml(text) { const d = document.createElement('div'); d.textContent = text; return d.innerHTML; }

        copyRoomLink() {
            if (!this.roomId) return;
            const base = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '') + window.location.pathname;
            this.copyToClipboard(base + '?room=' + this.roomId, 'Room link copied!');
        }

        copyRoomCode() {
            if (!this.roomId) return;
            this.copyToClipboard(this.roomId, 'Room code copied!');
        }

        copyToClipboard(text, msg) {
            navigator.clipboard.writeText(text).then(() => this.showToast(msg)).catch(() => {
                const ta = document.createElement('textarea');
                ta.value = text; document.body.appendChild(ta); ta.select();
                document.execCommand('copy'); document.body.removeChild(ta); this.showToast(msg);
            });
        }

        async leaveCall() {
            this.showLoading(true, 'Leaving call…');

            // Stop all intervals and timers
            if (this.streamHealthInterval) { clearInterval(this.streamHealthInterval); this.streamHealthInterval = null; }
            if (this.reconnectTimeout) { clearTimeout(this.reconnectTimeout); this.reconnectTimeout = null; }
            this.qualityIntervals.forEach(id => clearInterval(id)); this.qualityIntervals.clear();
            if (this._spotlightSyncInterval) { clearInterval(this._spotlightSyncInterval); this._spotlightSyncInterval = null; }
            if (this._silentAudio) { try { this._silentAudio.ctx.close(); } catch(e){} this._silentAudio = null; }

            // Tear down Firebase listeners
            this.tearDownFirebaseListeners();

            // Destroy all peer connections
            this.peers.forEach(p => { try { p.destroy(); } catch (e) {} }); this.peers.clear();

            // Stop all media tracks
            if (this.localStream) {
                this.localStream.getTracks().forEach(t => { try { t.stop(); } catch (e) {} });
                this.localStream = null;
            }

            // Remove self from Firebase room, clean up empty room
            if (database && this.roomId) {
                try {
                    const rr = database.ref(`rooms/${this.roomId}`);
                    await rr.child('participants').child(this.userId).remove();
                    const ps = await rr.child('participants').once('value');
                    if (!ps.exists() || ps.numChildren() === 0) await rr.remove();
                } catch (e) { console.warn('Firebase cleanup error:', e); }
            }

            // Always clear ALL cookies and storage
            this.clearUserCookies();

            // Hard page reload — fresh state, no stale UI or JS state
            window.location.replace(window.location.pathname);
        }

        handlePageUnload() {
            // Clear all cookies on tab close/refresh too
            if (this.roomId && database) {
                database.ref(`rooms/${this.roomId}/participants/${this.userId}`).remove();
            }
            this.clearUserCookies();
        }
    }

    window.addEventListener('beforeunload', () => { if (window.videoCallApp) window.videoCallApp.handlePageUnload(); });

    // ── Reposition browser extension iframes that overlap the call controls ──
    // The nr-ext-rsicon iframe is injected by the "New Relic" or similar browser extension.
    // We observe the body for it and push it above the controls bar.
    function repositionExtensionIframe() {
        const iframe = document.getElementById('nr-ext-rsicon');
        if (iframe) {
            iframe.style.setProperty('bottom', '90px', 'important');
            iframe.style.setProperty('top', 'auto', 'important');
            iframe.style.setProperty('right', '16px', 'important');
            iframe.style.setProperty('left', 'auto', 'important');
            iframe.style.setProperty('position', 'fixed', 'important');
        }
    }

    const _extObserver = new MutationObserver(() => repositionExtensionIframe());
    _extObserver.observe(document.body, { childList: true, subtree: false, attributes: true, attributeFilter: ['style'], attributeOldValue: false });
    // Also run immediately in case it's already present
    document.addEventListener('DOMContentLoaded', repositionExtensionIframe);
    document.addEventListener('DOMContentLoaded', () => {
        lucide.createIcons();
        if (typeof SimplePeer === 'undefined') { alert('Failed to load video call library. Please refresh.'); return; }
        try { window.videoCallApp = new VideoCallApp(); } catch (e) { console.error(e); alert('Failed to start app. Please refresh.'); }
    });
    </script>
</body>
</html>
